####OS ASST2 EXTENDED TASK - PLANNING AND DESIGN DOCUMENT####

# sys_getpid #

- The actual implementation of the sys_getpid function is trivial as it
can never fail and just returns the pid attached to the calling
processes struct. The acquiring of pid’s by processes is where the
bulk of the work happens.

- We assign pid’s to processes (upon process creation) incrementally
from PID_MIN until PID_MAX is hit, however, because processes can
exit and free up pid’s, we wrap around and search again to find one
of these free pid’s once PID_MAX is hit.

- We achieve this by having a system process table (which is just a
doubly-linked list of all the process structs) and a pointer to the
last process made. We can then simply start checking pid’s from
lastprocs location in the list (and start at its pid) and circulate
around the linked list until we get a free pid.

- We also use a proc_cnt global variable to ensure that once we have
PID_MAX pid’s allocated a new process cannot be made (it would just
stay in pid acquire loop forever until a process exits).


# sys_fork #

- We create the child process with proc_create_runprogram which
essentially sets up a struct with fields to be filled in i.e. empty
fdt table, null address space. It does however initialize some fields
as copies of the parent program (same current working directory and
name) and also acquires a unique pid.

- We then fill in the process struct taking into consideration that
some objects are shared between the parent and child instead of
copied.

- We copy the address space of the parent with as_copy so that the
child has the same text, variables etc. (it is essentially the same
process but in a different address space).

- The fdt table is process specific so we create an fdt for the child
process but the actual fdt entries they point to that represent open
files are not copied but instead shared. For this reason we do not
create any new oft entries but instead loop through the parent
processes fdt table and copy across any pointers to the newly created
child fdt (at the lowest available fd index by convention). We also
initialize the fdt count to that of the parent processes.

- Since fork creates a new process it needs to return twice on success
but only once on failure (because the new process will not be made in
this case). Furthermore, if successful the two processes must return
different values for identification (parent returns child pid, child
return 0) and so we must have two different trapframes.

- In the parent, the trapframe can remain where it is (kernel stack)
but for the child process it needs to copied onto the process stack
(required by mips_usermode). To achieve this we malloc a copy of the
parents trapframe, then once we are in the child's thread (called
enter_forked_process) we create a local trapframe struct (so it goes
on the stack) then we copy in the contents from the parent trap frame
on the heap via a pointer and then free it.

- Now we have two different trap frames so we can set the different
return values in each in the respective functions.

- We also ensure we have everything set up and valid before we call
thread_fork because it eventually calls enter_forked_process and then
mips_usermode from which you cannot return and so any errors must be
caught prior to this as it is assumed the fork is successful at this
stage.
